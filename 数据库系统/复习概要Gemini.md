### **第一章：数据库系统导论**

这部分主要是建立对数据库系统的基本认识。

| **概念**                  | **描述**                                                     | **举例**                                                     |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据 (Data)**           | 描述事物的符号记录，是数据库中存储的基本对象。               | 学生姓名 "张三"，年龄 "20"。                                 |
| **数据库 (DB)**           | 长期储存在计算机内、有组织的、可共享的大量数据的集合。       | 存储整个学校所有学生、课程和成绩信息的集合。                 |
| **数据库管理系统 (DBMS)** | 位于用户与操作系统之间的一层数据管理软件。用于科学地组织和存储数据、高效地获取和维护数据。 | MySQL, Oracle, SQL Server, PostgreSQL。                      |
| **数据库系统 (DBS)**      | 由数据库、数据库管理系统、应用程序和用户组成的系统。         | 一个完整的教务管理系统。                                     |
| **数据独立性**            | 指用户的应用程序与数据库的逻辑结构或物理结构相互独立。       | **物理独立性**：存储结构改变（如更换硬盘），应用程序不变。**逻辑独立性**：数据逻辑结构改变（如增加一个字段），应用程序不变。 |
| **三级模式结构**          | 描述数据库系统内部的三个层次：外模式、模式和内模式。         | **外模式 (External Schema)**：也称子模式或用户模式，是用户能看到和使用的局部数据的逻辑结构和特征的描述。**模式 (Schema)**：也称概念模式，是数据库中全体数据的逻辑结构和特征的描述。**内模式 (Internal Schema)**：也称存储模式，是数据物理结构和存储方式的描述。 |

------

### **第二章：关系模型与关系代数**

这是数据库系统的核心理论基础。

- **关系模型 (Relational Model)**: 用二维表格（称为**关系**）来表示数据和数据之间的联系。

| **核心术语**         | **解释**                                                     |
| -------------------- | ------------------------------------------------------------ |
| **关系 (Relation)**  | 一个二维表，每个关系有唯一的名称。                           |
| **元组 (Tuple)**     | 表中的一行，对应一条记录。                                   |
| **属性 (Attribute)** | 表中的一列，每个属性有唯一的名称。                           |
| **域 (Domain)**      | 属性的取值范围。                                             |
| **码 (Key)**         | 用于唯一标识元组的属性或属性组合。                           |
| **关系完整性约束**   | **实体完整性**: 主码不能为空值 (NULL)。**参照完整性**: 外码的值必须是其参照关系中某个元组的主码值，或者为空值。**用户定义的完整性**: 针对某一具体应用的数据必须满足的语义要求。 |

- **关系代数 (Relational Algebra)**: 一种抽象的查询语言，用对关系的运算来表达查询。

| **运算**                         | **符号** | **描述**                                                     |
| -------------------------------- | -------- | ------------------------------------------------------------ |
| **并 (Union)**                   | ∪        | 合并两个关系的元组，并去除重复。要求两个关系有相同的属性数和对应的域。 |
| **差 (Difference)**              | −        | 从第一个关系中去除同时存在于第二个关系中的元组。             |
| **交 (Intersection)**            | ∩        | 取两个关系中都存在的元组。                                   |
| **笛卡尔积 (Cartesian Product)** | ×        | 将两个关系的元组合并成所有可能的组合。                       |
| **选择 (Selection)**             | σ        | 根据条件筛选出满足条件的元组。例如：σ年龄>20(学生)           |
| **投影 (Projection)**            | π        | 从关系中选择出若干属性列组成新的关系，并去除重复行。例如：π姓名,专业(学生) |
| **连接 (Join)**                  | ⋈        | 通常与选择和笛卡尔积相关，最常用的是自然连接。**自然连接 (Natural Join)**: 在两个关系的公共属性上进行等值连接，并去除重复的公共属性列。 |
| **除 (Division)**                | ÷        | 在关系 R(X, Y) 和 S(Y) 中，R÷S 得到一个新的关系，其属性为 X，元组为 R 中那些与 S 中所有元组都有对应关系的 Y 值。 |

------

### **第三章：结构化查询语言 SQL**

SQL 是在关系数据库上执行查询、数据操作和数据定义的标准语言。

#### **数据定义语言 (DDL)**

用于定义和管理数据库对象（如表、索引）。

- 创建表 `CREATE TABLE`:

  ```mysql
  CREATE TABLE Students (
      SID CHAR(9) PRIMARY KEY,
      SName VARCHAR(20) NOT NULL,
      Age INT,
      Major VARCHAR(50),
      CONSTRAINT age_check CHECK (Age >= 18)
  );
  ```
  
- 修改表 `ALTER TABLE`:

  ```mysql
  ALTER TABLE Students ADD COLUMN Gender CHAR(1); -- 添加列
  ALTER TABLE Students DROP COLUMN Age; -- 删除列
  ```
  
- 删除表 `DROP TABLE`:

  ```mysql
  DROP TABLE Students;
  ```

#### **数据查询语言 (DQL)**

用于从表中检索数据。

- 基本查询 `SELECT`:

  ```mysql
  SELECT SName, Major
  FROM Students
  WHERE Age > 20 AND Major = '计算机科学'
  ORDER BY SName DESC;
  ```
  
- 聚合函数:  `COUNT()` ,  `SUM()` ,  `AVG()` ,  `MAX()`,  `MIN()`

  ```mysql
  SELECT Major, COUNT(SID) AS NumberOfStudents
  FROM Students
  GROUP BY Major
  HAVING COUNT(SID) > 30;
  ```
  
- 连接查询 `JOIN`:

  ```mysql
  SELECT s.SName, c.CName
  FROM Students s
  JOIN Enrollments e ON s.SID = e.SID
  JOIN Courses c ON e.CID = c.CID;
  ```
  
- 子查询 (Subquery):

  ```mysql
  SELECT SName
  FROM Students
  WHERE SID IN (SELECT SID FROM Enrollments WHERE CID = 'CS101');
  ```

#### **数据操纵语言 (DML)**

用于添加、删除和修改数据。

- 插入 `INSERT`:

  ```mysql
  INSERT INTO Students (SID, SName, Age, Major)
  VALUES ('123456789', '王五', 21, '物理学');
  ```
  
- 更新 `UPDATE`:

  ```mysql
  UPDATE Students
  SET Major = '电子工程'
  WHERE SName = '王五';
  ```
  
- 删除 `DELETE`:

  ```mysql
  DELETE FROM Students
  WHERE SID = '123456789';
  ```

------

### **第四章：数据库设计与范式理论**

这部分的目标是设计出结构良好、没有冗余的关系模式。

- **函数依赖 (Functional Dependency, FD)**: 关系 R 中的一个属性（组）X 的值能唯一确定另一个属性（组）Y 的值，记为 X→Y。
  - **平凡函数依赖**: 如果 Y⊆X，则 X→Y 是平凡的。
  - **非平凡函数依赖**: 如果 Y⊆X，则 X→Y 是非平凡的。
  - **完全函数依赖**: 在 X→Y 中，如果 X 的任何一个真子集都不能决定 Y，则称 Y 对 X 完全函数依赖。
  - **部分函数依赖**: 如果 X 的某个真子集可以决定 Y，则称 Y 对 X 部分函数依赖。
  - **传递函数依赖**: 如果 X→Y, Y→Z，且 Y 不决定 X，Z 不属于 Y，则称 Z 对 X 传递函数依赖。
- **范式 (Normal Form, NF)**:

| **范式**                 | **定义**                                                     | **目标**                                   |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| **第一范式 (1NF)**       | 关系中的所有属性都是**原子**的，不可再分。                   | 这是关系模型的基本要求。                   |
| **第二范式 (2NF)**       | 在 1NF 基础上，消除**非主属性**对码的**部分函数依赖**。      | 确保每个非主属性都完全依赖于整个主码。     |
| **第三范式 (3NF)**       | 在 2NF 基础上，消除**非主属性**对码的**传递函数依赖**。      | 确保非主属性之间没有传递依赖关系。         |
| **BCNF (Boyce-Codd NF)** | 在 3NF 基础上，消除**主属性**对码的**部分和传递函数依赖**。要求每个决 定因素都包含码。 | 更严格的范式，解决了主属性内部的依赖问题。 |

**记忆技巧**: 1NF (属性原子性) -> 2NF (消除部分依赖) -> 3NF (消除传递依赖) -> BCNF (消除所有决定因素中的非码依赖)。

------

### **第五章：事务处理**

确保数据库在并发访问和系统故障时仍能保持数据一致性。

- **事务 (Transaction)**: 用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。
- **ACID 特性**:

| **特性**                 | **英文**    | **描述**                                                     |
| ------------------------ | ----------- | ------------------------------------------------------------ |
| **原子性 (Atomicity)**   | Atomicity   | 事务是最小的执行单位，不可分割。事务中的所有操作要么全部完成，要么全部失败回滚。 |
| **一致性 (Consistency)** | Consistency | 事务执行前后，数据库必须从一个一致性状态转变到另一个一致性状态。 |
| **隔离性 (Isolation)**   | Isolation   | 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的。 |
| **持久性 (Durability)**  | Durability  | 一个事务一旦提交，它对数据库中数据的改变就是永久性的。       |

- **并发控制 (Concurrency Control)**:

  - **问题**: 脏读 (Dirty Read)、不可重复读 (Non-repeatable Read)、幻读 (Phantom Read)。

  - 技术:

    - **锁 (Locking)**: **共享锁 (S-lock)** 用于读，**排他锁 (X-lock)** 用于写。
    - **两段锁协议 (2PL)**: 事务分为**加锁阶段**和**解锁阶段**，一旦开始解锁就不能再加锁。
    - **时间戳排序 (Timestamp Ordering)**: 为每个事务分配一个唯一的时间戳。
    - **多版本并发控制 (MVCC)**: 为数据保留多个版本，读操作不加锁。
  
- **数据库恢复 (Recovery)**:

  - **故障类型**: 事务内部故障、系统故障、介质故障。

  - 技术:

    - **日志 (Log)**: 记录所有对数据库的更新操作。
    - **备份 (Backup)**: 定期创建数据库副本。
    - **检查点 (Checkpoint)**: 定期将内存中的数据写入磁盘，并记录一个检查点，可以缩短恢复时间。

