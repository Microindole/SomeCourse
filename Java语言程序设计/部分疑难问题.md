### 包装类的普通数据类型

| 特性         | 基本数据类型 (Primitive Type)                                | 包装类 (Wrapper Class)                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **本质**     | 普通的值、非对象                                             | 是一个对象                                                   |
| **默认值**   | 有明确的默认值。例如：&lt;br> `int` 是 `0`&lt;br> `boolean` 是 `false` | 默认值为 `null`                                              |
| **存储位置** | 主要存储在 **栈（Stack）** 中，访问速度快。                  | 存储在 **堆（Heap）** 中，变量持有的是堆中对象的引用。       |
| **功能**     | 只能进行基本的算术运算和赋值。                               | 作为对象，可以调用其自身的方法。例如：&lt;br> `Integer.parseInt("123")`&lt;br> `integer.equals(otherInteger)` |
| **用法**     | 用于高性能的简单计算。                                       | 1.  **集合框架（Collections）** 中必须使用，如 `ArrayList<Integer>`。&lt;br> 2.  **泛型（Generics）** 中必须使用。&lt;br> 3.  需要用 `null` 表示“未赋值”或“不存在”的状态时。 |
| **性能**     | 通常性能更高，因为没有对象创建和管理的开销。                 | 性能相对较低，因为涉及到对象的创建和垃圾回收。               |





### 普通类型转换和字符串的转换

| 特性         | `(int)` 类型转换                                           | `Integer.parseInt(String)` 字符串解析                        |
| ------------ | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **操作对象** | **数值类型** (`double`, `long`, `char` 等) 和其包装类      | **`String` 类型**                                            |
| **本质**     | 改变内存中值的表示，或进行类型范围收缩                     | 分析字符串内容，并生成一个全新的`int`值                      |
| **主要用途** | 在不同精度的数字间转换，如`double`转`int`                  | 将来自用户输入、文件、网络的**文本数据**转换为数字           |
| **错误处理** | 编译时检查类型兼容性；运行时可能发生**精度丢失**或**溢出** | 运行时如果字符串格式不合法，会抛出 **`NumberFormatException`** |
| **语法**     | 运算符 `(int) value`                                       | 静态方法调用 `Integer.parseInt(string)`                      |



### 

### random方法选择

| 特性         | `Math.random()`      | `java.util.Random`             | `ThreadLocalRandom`             |
| ------------ | -------------------- | ------------------------------ | ------------------------------- |
| **获取方式** | 静态方法             | `new Random()`                 | `ThreadLocalRandom.current()`   |
| **线程安全** | 存在性能瓶颈         | 线程安全，但有性能瓶颈         | **线程安全且高效**              |
| **性能**     | 单线程OK，多线程差   | 单线程OK，多线程差             | **高**                          |
| **灵活性**   | 低，只能生成double   | 高，可生成多种类型             | **高**，API更方便               |
| **推荐场景** | 简单脚本、单线程应用 | 单线程应用、需要指定种子的场景 | **所有多线程应用（Web服务等）** |
| **推荐度**   | ⭐⭐☆☆☆                | ⭐⭐⭐☆☆                          | ⭐⭐⭐⭐⭐ **(首选)**                |





### case支持的类型

| 类型 (Type)                             | 引入版本 (Introduced) | 说明 (Notes)                                          |
| --------------------------------------- | --------------------- | ----------------------------------------------------- |
| `int`, `byte`, `short`, `char`          | 原始版本              | 基础整型及可自动提升为 `int` 的类型。                 |
| `Integer`, `Byte`, `Short`, `Character` | Java 5                | 对应的包装类，通过**自动拆箱** (Auto-unboxing) 支持。 |
| `enum`                                  | Java 5                | 类型安全的枚举常量匹配，非常推荐使用。                |
| `String`                                | Java 7                | 方便的字符串匹配，是重要的语法糖。                    |

| 逻辑 (Logic) | 表示符号 / 关键字 (Symbol / Keyword) | 使用场景 (Context)                                           | 示例 (Example)                             |
| ------------ | ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| **或 (OR)**  | (无特定符号)                         | 传统 `switch` (冒号`:`)，通过**堆叠`case`实现。              | `case 'A': case 'E': ...`                  |
| 或 (OR)      | 逗号 `,`                             | 现代 `switch` (箭头`->`)，用于分隔多个`case`标签。           | `case 'A', 'E', 'I' -> ...`                |
|              |                                      |                                                              |                                            |
| 与 (AND)     | `if` 语句                            | 在`case`的代码块内部，添加额外的判断条件。(通用方法)**       | `case "USER": if (isVip) { ... }`          |
| **与 (AND)** | **`when` 关键字**                    | **Switch模式匹配**中，作为 `case` 的附加守卫条件。 (Java 17+) | `case String s when s.length() > 5 -> ...` |





### Java的Math类

> ### **常用方法分类详解**
>
> 我们将最常用的方法分为几类来介绍。
>
> #### **1. 取整与舍入**
>
> 这是`Math`类中最常用也最容易混淆的一组方法。
>
> | 方法 (Method)                | 返回类型     | 描述 (Description)                                           | 示例 (Example)                                               |
> | ---------------------------- | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | `Math.ceil(double a)`        | `double`     | **向上取整** (Ceiling/天花板)。返回大于或等于参数的最小整数值。 | `Math.ceil(9.01)`  -> `10.0`                                 |
> | `Math.floor(double a)`       | `double`     | **向下取整** (Floor/地板)。返回小于或等于参数的最大整数值。  | `Math.floor(9.99)` -> `9.0`                                  |
> | `Math.round(double/float a)` | `long`/`int` | **四舍五入**。**将参数加上0.5后，再调用 `floor` 向下取整。** | `Math.round(9.5)`  -> `10` &lt;br> `Math.round(9.49)` -> `9` |
>
> #### **2. 最大值、最小值、绝对值**
>
> 这些方法都被重载以支持 `int`, `long`, `float`, `double` 四种类型。
>
> | 方法 (Method)    | 描述 (Description)       | 示例 (Example)             |
> | ---------------- | ------------------------ | -------------------------- |
> | `Math.max(a, b)` | 返回两个参数中的最大值。 | `Math.max(10, 20)` -> `20` |
> | `Math.min(a, b)` | 返回两个参数中的最小值。 | `Math.min(10, 20)` -> `10` |
> | `Math.abs(a)`    | 返回参数的绝对值。       | `Math.abs(-10)` -> `10`    |
>
> #### **3. 指数、对数、平方根**
>
> | 方法 (Method)                  | 描述 (Description)                      | 示例 (Example)              |
> | ------------------------------ | --------------------------------------- | --------------------------- |
> | `Math.pow(double a, double b)` | 计算 **a 的 b 次方** (ab)。             | `Math.pow(2, 3)` -> `8.0`   |
> | `Math.sqrt(double a)`          | 计算 a 的**平方根** (sqrta)。           | `Math.sqrt(9)` -> `3.0`     |
> | `Math.cbrt(double a)`          | 计算 a 的**立方根** (sqrt[3]a)。        | `Math.cbrt(27)` -> `3.0`    |
> | `Math.exp(double a)`           | 计算 **e 的 a 次方** (ea)。             | `Math.exp(1)` -> `2.718...` |
> | `Math.log(double a)`           | 计算 a 的**自然对数** (ln a)。          | `Math.log(Math.E)` -> `1.0` |
> | `Math.log10(double a)`         | 计算 a 的**以10为底的对数** (log₁₀ a)。 | `Math.log10(100)` -> `2.0`  |
>
> #### **4. 三角函数**
>
> **注意**：所有三角函数的参数都要求是**弧度 (radians)**，而不是角度 (degrees)。
>
> | 方法 (Method)                   | 描述 (Description) |
> | ------------------------------- | ------------------ |
> | `Math.sin(double a)`            | 计算 a 的正弦值。  |
> | `Math.cos(double a)`            | 计算 a 的余弦值。  |
> | `Math.tan(double a)`            | 计算 a 的正切值。  |
> | `Math.toDegrees(double angrad)` | 将弧度转换为角度。 |
> | `Math.toRadians(double angdeg)` | 将角度转换为弧度。 |
>
> #### **5. 随机数**
>
> | 方法 (Method)   | 描述 (Description)                                   |
> | --------------- | ---------------------------------------------------- |
> | `Math.random()` | 返回一个 `[0.0, 1.0)` 范围内的 `double` 型伪随机数。 |
>
> 





### Character类与包装类

> ### **常用静态方法分类详解**
>
> 这是 `Character` 类最精华、最常用的部分。
>
> #### **1. 字符类型判断**
>
> 这组方法用于判断一个字符是否属于某种特定的类型。
>
> | 方法 (Method)                        | 描述 (Description)                                           | 示例 (Example)                                               |
> | ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | `Character.isLetter(char ch)`        | 判断指定字符是否为**字母**。                                 | `isLetter('a')` -> `true` &lt;br> `isLetter('9')` -> `false` |
> | `Character.isDigit(char ch)`         | 判断指定字符是否为**数字** ('0'-'9')。                       | `isDigit('7')` -> `true` &lt;br> `isDigit('a')` -> `false`   |
> | `Character.isLetterOrDigit(char ch)` | 判断指定字符是否为**字母或数字**。                           | `isLetterOrDigit('T')` -> `true` &lt;br> `isLetterOrDigit('8')` -> `true` |
> | `Character.isWhitespace(char ch)`    | 判断指定字符是否为**空白字符**（如空格、制表符`\t`、换行符`\n`等）。 | `isWhitespace(' ')` -> `true` &lt;br> `isWhitespace('\n')` -> `true` |
> | `Character.isUpperCase(char ch)`     | 判断指定字符是否为**大写字母**。                             | `isUpperCase('A')` -> `true` &lt;br> `isUpperCase('a')` -> `false` |
> | `Character.isLowerCase(char ch)`     | 判断指定字符是否为**小写字母**。                             | `isLowerCase('z')` -> `true` &lt;br> `isLowerCase('Z')` -> `false` |
>
> #### **2. 大小写转换**
>
> | 方法 (Method)                    | 描述 (Description)             | 示例 (Example)                                               |
> | -------------------------------- | ------------------------------ | ------------------------------------------------------------ |
> | `Character.toUpperCase(char ch)` | 将指定字符转换为**大写**形式。 | `toUpperCase('a')` -> `'A'` &lt;br> `toUpperCase('7')` -> `'7'` |
> | `Character.toLowerCase(char ch)` | 将指定字符转换为**小写**形式。 | `toLowerCase('B')` -> `'b'` &lt;br> `toLowerCase('!')` -> `'!'` |
>
> #### **3. 其他常用方法**
>
> | 方法 (Method)                              | 描述 (Description)                                           | 示例 (Example)                                               |
> | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | `Character.toString(char ch)`              | 将指定的 `char` 转换为只包含该字符的 `String` 对象。         | `toString('c')` -> `"c"`                                     |
> | `Character.getNumericValue(char ch)`       | 返回字符代表的 `int` 值。它比 `ch - '0'` 更强大，可以处理罗马数字等。 | `getNumericValue('9')` -> `9`                                |
> | `Character.isJavaIdentifierStart(char ch)` | 判断字符是否可作为Java标识符的**首字符**（字母、`$`、`_`）。 | `isJavaIdentifierStart('a')` -> `true` &lt;br> `isJavaIdentifierStart('5')` -> `false` |
> | `Character.isJavaIdentifierPart(char ch)`  | 判断字符是否可作为Java标识符的**非首字符**部分。             | `isJavaIdentifierPart('a')` -> `true` &lt;br> `isJavaIdentifierPart('5')` -> `true` |
>
> ------
>
> ### **作为包装类的功能**
>
> 虽然静态方法更常用，但`Character`作为包装类，也具备对象的基本功能。
>
> - **创建对象 (实例化)**
>
>   - `Character c1 = new Character('a');`  - **已废弃 (Deprecated)**，不推荐使用。
>   - `Character c2 = Character.valueOf('a');` - **推荐使用**。此方法会缓存常用的字符（0-127），性能更好。
>
> - **获取原始值**
>
>   - `char ch = c2.charValue();` - 从包装类对象中获取其包装的 `char` 值。
>
> - **自动装箱与拆箱 (Autoboxing & Unboxing)** Java 编译器会自动在 `char` 和 `Character` 之间进行转换，让代码更简洁。
>
>   Java
>
>   ```
>   // 自动装箱: char -> Character
>   Character wrapperChar = 'a'; 
>   
>   // 自动拆箱: Character -> char
>   char primitiveChar = wrapperChar; 
>   ```
>
> ------





### ==和equals（）

> 注意：这里的equals()是已有的类写好的，自己写的类要重写(没有重写的话两者一模一样)

| 特性 (Characteristic) | `==` 运算符 (Operator)                                     | `equals()` 方法 (Method)                                     |
| --------------------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| **本质**              | 运算符                                                     | 方法                                                         |
| **比较基本类型时**    | 比较**值**是否相等。                                       | **不能使用** (会导致编译错误)。                              |
| **比较对象类型时**    | 比较两个引用的**内存地址**是否相同（是否指向同一个对象）。 | 默认行为与`==`相同，但通常被重写为比较对象的**内容或状态**是否相等。 |
| **来源**              | Java语言内置的运算符。                                     | `java.lang.Object` 类中定义的方法。                          |
| **能否被重写**        | ❌ **不能**                                                 | ✅ **可以**，并且强烈建议自定义类根据业务需求进行重写。       |

| 类 (Class)                                                   | 是否重写了 `equals()` ? | 调用 `a.equals(b)` 的效果                    |
| ------------------------------------------------------------ | ----------------------- | -------------------------------------------- |
| **`Object`**                                                 | (基类，提供默认实现)    | 比较**内存地址** (`a == b`)                  |
| **未重写的自定义类**(如之前的`Student`)                      | ❌ **否**                | 继承 `Object` 的行为，**比较内存地址**。     |
| **`String`**,**`Integer`, `Double`**,**`ArrayList`, `Date`** ... | ✅ **是**                | **执行各自类中写好的、专属的内容比较逻辑**。 |









### 数组的初始化

| 特性 (Characteristic) | `int[] a = {1, 2, 3};` &lt;br> (静态初始化)               | `int[] a = new int[3]; a[0]=1; ...` &lt;br> (动态初始化后赋值) |
| --------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| **名称**              | **静态初始化 (Static Initialization)**                    | **动态初始化 (Dynamic Initialization)**                      |
| **语法特点**          | **声明、创建、赋值一气呵成**。代码非常简洁。              | 声明和创建（分配空间）先行，然后通过索引**逐个赋值**。       |
| **数组大小**          | 由大括号 `{}` 中元素的**个数隐式决定** (编译器自动计算)。 | 在 `new int[size]` 中**显式指定**数组的大小。                |
| **适用场景**          | 当数组的初始内容在编码时就**完全确定**时。                | 当数组的大小提前确定，但其内容需要在程序**运行时动态计算或获取**时（如用户输入、文件读取）。 |
| **使用时机**          | **只能在声明变量的同时使用。**                            | 声明和赋值可以分开进行，**更灵活**。                         |

“静态初始化”的简洁写法有其限制。

**1. 静态初始化 (`{...}`) 必须在声明时完成**

Java

```
// ✅ 正确：声明的同时进行静态初始化
int[] arrayA = {10, 20, 30};

// ❌ 错误：不能先声明，再用静态初始化的方式赋值
int[] arrayB;
// arrayB = {40, 50, 60}; // !!! 这会导致编译错误 (Compile Error) !!!
```

**2. 如何解决上面的错误？**

如果你确实需要先声明一个数组引用，之后再给它赋上确定的值，你需要使用 `new` 关键字，这实际上是静态和动态初始化的结合：

Java

```
int[] arrayB;
// ✅ 正确：使用 new 关键字来重新初始化一个数组
arrayB = new int[]{40, 50, 60}; 
```

`new int[]{...}` 这种写法创建了一个“匿名数组”，它可以在任何需要数组对象的地方使用，比如重新给变量赋值，或者作为方法参数传递。





### Array和ArrayList

> ### **核心区别对比表格**
>
> | 特性 (Characteristic)        | `Array` (数组)                                               | `ArrayList` (列表)                                           |
> | ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | **1. 大小 (Size)**           | 📏 **固定长度 (Fixed)**。一旦创建，其长度**永远不能改变**。   | 🌊 **可变长度 (Dynamic)**。可以根据需要**随时添加或删除**元素，其大小会自动增长或缩小。 |
> | **2. 数据类型 (Data Types)** | ✅ 可以存储**基本数据类型** (`int`, `double` 等) 和 **对象类型** (`String` 等)。 | ❌ **只能存储对象类型**。如果要存`int`，必须使用其包装类`Integer`。 (Java的自动装箱机制简化了这一过程) |
> | **3. 性能 (Performance)**    | **高**。通过索引直接访问内存地址，速度非常快。               | **相对较低**。访问元素需要调用`get()`方法，有额外开销。当`ArrayList`容量不足时，**自动扩容会涉及创建新数组和复制旧元素，有性能损耗**。 |
> | **4. 功能/API**              | **功能非常有限**。只有一个`length`属性来获取长度。其他操作（如排序、搜索）依赖于`Arrays`工具类。 | **功能非常丰富**。提供了大量的内置方法，如`add()`, `remove()`, `get()`, `set()`, `size()`, `contains()`, `indexOf()`等，使用非常方便。 |
> | **5. 本质**                  | Java语言的**内置核心特性**。                                 | Java集合框架 (`java.util`包) 中的一个**类**，它实现了`List`接口。 |
> | **6. 泛型 (Generics)**       | ❌ **不支持**。                                               | ✅ **支持**。通过泛型可以限定`ArrayList`中存储的元素类型，提供编译时类型安全检查。 |
>
> ------
>
> ### **代码语法对比**
>
> | 操作              | `Array` (数组)                                       | `ArrayList` (列表)                                           |
> | ----------------- | ---------------------------------------------------- | ------------------------------------------------------------ |
> | **声明与创建**    | `int[] array = new int[3];`                          | `ArrayList<Integer> list = new ArrayList<>();`               |
> | **添加/修改元素** | `array[0] = 100;`                                    | `list.add(100);` &lt;br> `list.add(0, 100);` (在指定位置添加) &lt;br> `list.set(0, 200);` (修改指定位置) |
> | **获取元素**      | `int value = array[0];`                              | `int value = list.get(0);`                                   |
> | **获取长度/大小** | `int len = array.length;` &lt;br> (注意：是**属性**) | `int size = list.size();` &lt;br> (注意：是**方法**)         |
> | **遍历**          | `for (int i=0; ...)`&lt;br>`for (int num : array)`   | `for (int i=0; ...)`&lt;br>`for (Integer num : list)`&lt;br>`list.forEach(...)`&lt;br>`Iterator` |
>
> ------
>
> ### **底层实现**
>
> `ArrayList` 的底层**就是用一个`Array`来实现的**。
>
> - 当你创建一个`ArrayList`时，它内部会初始化一个默认大小的数组。
>
> - 当你不断
>
>   ```
>   add()
>   ```
>
>   元素，导致内部数组空间不足时，
>
>   ```
>   ArrayList
>   ```
>
>   会自动：
>
>   1. 创建一个**更大的新数组**（通常是原大小的1.5倍）。
>   2. 将旧数组中的所有元素**复制**到新数组中。
>   3. 丢弃旧数组，让引用指向新数组。
>
> - 这个过程就是`ArrayList`能够“动态”增长的秘密，但也是其性能开销的来源。
>
> ------
>
> ### **如何选择？—— 使用场景**
>
> | 选择...                | 当... (When...)                                              |
> | ---------------------- | ------------------------------------------------------------ |
> | **`Array`** (数组)     | 1. 在编写代码时，你**已经明确知道需要存储的元素个数**，并且这个数量**不会再改变**。&lt;br>2. 对性能有极致要求，特别是需要频繁访问元素，并且存储的是**基本数据类型**时。 |
> | **`ArrayList`** (列表) | 1. **在绝大多数情况下**，这都是你的首选。&lt;br>2. 当你不确定需要存储多少个元素时。&lt;br>3. 当你需要频繁地**添加和删除**元素时。&lt;br>4. 当你需要使用集合框架提供的丰富功能时。 |
>
> **总结**：`ArrayList`可以看作是一个**功能更强大、使用更灵活的数组**。它牺牲了微小的性能，换来了巨大的便利性和动态扩展能力。因此，在日常开发中，除非有特定理由，否则**优先考虑使用`ArrayList`**。





### Arrays类

| 方法类别       | 核心静态方法                                       | 核心功能                                    |
| -------------- | -------------------------------------------------- | ------------------------------------------- |
| **转为字符串** | `toString(array)`                                  | 返回数组内容的字符串表示，如`"[1, 2, 3]"`。 |
| **排序**       | `sort(array)`                                      | 对数组进行升序排序。                        |
| **搜索**       | `binarySearch(array, key)`                         | 在已排序的数组中快速查找指定元素。          |
| **比较**       | `equals(array1, array2)`                           | 比较两个数组的内容是否完全相同。            |
| **填充**       | `fill(array, value)` `fill(array,start,end,value)` | 用指定值填充数组。                          |
| **复制**       | `copyOf(original, newLength)`                      | 复制数组到指定新长度。                      |
|                | `copyOfRange(original, from, to)`                  | 复制数组的指定范围。                        |
| **转为列表**   | `asList(array)`                                    | 将数组转换为一个`List`视图。                |
| **转为流**     | `stream(array)`                                    | (Java 8+) 将数组转换为`Stream`流。          |





### Java类属性权限

>**Java四种访问权限级别对比**

这张表格可以清晰地展示四种访问修饰符的权限范围，包括默认的“包私有”。

| 修饰符 (Modifier)          | 同一类中 (Same Class) | 同一包中 (Same Package) | 不同包的子类 (Subclass from different package) | 不同包的非子类 (Other class from different package) |
| -------------------------- | --------------------- | ----------------------- | ---------------------------------------------- | --------------------------------------------------- |
| **`public`**               | ✅                     | ✅                       | ✅                                              | ✅                                                   |
| **`protected`**            | ✅                     | ✅                       | ✅                                              | ❌                                                   |
| **(默认) package-private** | ✅                     | ✅                       | ❌                                              | ❌                                                   |
| **`private`**              | ✅                     | ❌                       | ❌                                              | ❌                                                   |





### 动态绑定情况

| 情况                                                        | 编译结果       | 运行结果                  | 原因分析                                                     |
| ----------------------------------------------------------- | -------------- | ------------------------- | ------------------------------------------------------------ |
| **1. 父类 `O` 和子类 `C` 都有 `xxx()`**(子类重写了父类方法) | ✅ **编译成功** | **执行子类 (`C`) 的方法** | **编译时**：检查 `O`，发现有 `xxx()` 方法，通过。**运行时**：`o1` 实际指向 `C` 的对象，`C` 重写了 `xxx()`，因此执行 `C` 的版本。**这是多态的经典体现**。 |
| **2. 仅子类 `C` 有 `xxx()`**(父类没有此方法)                | ❌ **编译失败** | (无)                      | **编译时**：检查 `O`，发现 `O` 类中**没有** `xxx()` 方法。编译器无法保证所有 `O` 类型的引用都能调用 `xxx()`，因此直接报错。 |
| **3. 仅父类 `O` 有 `xxx()`**(子类没有重写此方法)            | ✅ **编译成功** | **执行父类 (`O`) 的方法** | **编译时**：检查 `O`，发现有 `xxx()` 方法，通过。**运行时**：`o1` 实际指向 `C` 的对象，JVM在 `C` 中找不到 `xxx()`，于是**沿着继承链向上**找到并执行了父类 `O` 的版本。 |





### throw和throws

| 特性 (Characteristic) | `throw` 关键字                                          | `throws` 关键字                                              |
| --------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| **作用 (Purpose)**    | 主动抛出一个具体的异常实例。                            | 在方法签名上声明该方法可能抛出的异常类型。                   |
| **位置 (Location)**   | **方法体内部**，作为一条语句。                          | **方法签名中**，位于参数列表之后，方法体之前。               |
| **语法 (Syntax)**     | `throw new Exception("...");`                           | `void myMethod() throws Exception1, Exception2 { ... }`      |
| **后面跟的内容**      | 一个**异常对象实例** (a new instance of an exception)。 | 一个或多个**异常类名** (class names of exceptions)，用逗号隔开。 |
| **本质**              | 一个**执行动作**，它会中断当前方法的执行。              | 一个**方法契约的声明**，它告诉调用者需要处理这些潜在的异常。 |

| 特性                | `try-catch-finally` 语句块                                   | `throws` 关键字                                              |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **作用 (Purpose)**  | **处理异常**。捕获并执行补救或收尾操作。                     | **声明/抛出异常**。将处理责任转移给上级调用者。              |
| **位置 (Location)** | **方法体内部**。                                             | **方法签名中**，位于参数列表之后。                           |
| **本质**            | **程序执行块**，是真正的异常处理器。                         | **方法契约的一部分**，是一个给调用者的警告或声明。           |
| **处理结果**        | 异常在`catch`块中被**消费或终结**（除非`catch`中又`throw`了新异常）。程序可以继续往下执行。 | 异常被**传递或传播**到调用栈的上一层。当前方法的执行被中断。 |

